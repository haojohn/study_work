#####面向对象编程########

# 类的使用 ES6
1.在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数组、数值、函数等

2.对象由属性和方法组成：
    属性：事物的特征，在对象中用属性来表示
    方法：事物的行为，在对象中用方法来表示

3.类抽象了对象的公共部分，它泛指一大类，对象特指某一个，通过类实例化一个具体的对象

4.面向对象的思维特点：
    抽取对象共用的属性和行为封装成为一个类；对类进行实例化，获取类的对象

5.类的使用注意事项：
    ES6中 ，类没有变量提升，所以必须先定义类，才能通过类实例化对象。
    类里面的共有属性和方法一定要加this使用。
    constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者

# 构造函数和原型 ES6之前
1.在es6之前是没有类的概念的，可以通过构造函数来创建对象，构造函数里面放置的一般都是公共的属性和方法，通过new的形式来使用

2.实例成员和静态成员
    实例成员：就是构造函数内部通过this添加的成员，它只能通过实例化的对象来访问
    静态成员：在构造函数本身上添加的成员，它只能通过构造函数来访问

3.构造函数方法虽然好用，但是存在浪费内存的问题，每次实例化对象，都会给通用方法开辟一个内存空间并创建一遍，因此可以把这些通用方法放在构造函数的原型对象prototype上实现共享

4.构造函数原型对象prototype，构造函数通过原型prototype添加的函数方法是所有实例化对象所共享的，JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象；我们可以把那些通用的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法，避免了内存浪费

5.实例对象可以访问到构造函数的原型对象prototype上的方法，是因为每一个实例对象都会有一个对象原型属性_proto_，这个属性指向其构造函数的prototype原型对象，因此实例对象可以访问到，实例对象上的_proto_对象原型和构造函数的原型对象prototype是等价的true

6.constructor构造函数：实例的对象原型(_proto_)和构造函数的原型对象(prototype)里面都有一个共同的属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身，constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数

7.原型链：理解一张图即可，即实例对象通过对象原型(_proto_)以及原型对象(prototype)构成的一条链路，最顶层是Object.prototype,再往上Object.prototype._proto_就为空了

8.JavaScript的成员查找机制：按照原型链去查找，遵循就近原则，直到查到为止

9.原型对象this指向问题：不管是构造函数中的this，还是原型对象中的this都是指向它的调用者实例对象；利用原型对象可以扩展内置对象方法

10.call方法的作用：fn.call(thisArg,s1,s2,...),第一个作用是调用函数，第二个作用改变这个函数里的this指向

11.数组方法：
    循环遍历forEach： array.forEach(function(value,indx,array){})，在forEach里面使用return不会终止迭代，会一直循环完全部数据
    循环遍历 map：
    筛选数组filter：array.filter(function(value,index,array){}) 返回值是一个新的数组，返回所有满足条件的新数组
    查找某值some：array.some(function(value,index,array){}) 返回值是一个boolean值，如果找到满足的元素return true，则终止循环，不再继续往下查找，
    查找某值every：


12.trim方法去除字符串两端的空格，返回一个新的字符串，不会影响原先的字符串，let newStr = str.trim()

13.Object.keys(obj)，获取obj对象的所有属性，返回一个有属性值组成的数组，类似于for...in

14.Object.defineProperty(obj,prop,descriptor)，定义对象中新属性或修改原有的属性，三个参数必须都要有

15.函数内this指向问题：
    普通函数调用，this指向window；构造函数调用，this指向实例对象，原型对象里面的方法也是指向实例对象；对象方法调用，this指向该方法所属的对象；事件绑定方法，this指向绑定事件对象；定时器函数，this指向window；立即执行函数，this指向window

16.高阶函数：即把函数当作参数来传递使用，常用的回调函数

# call方法、bind方法、apply方法，都可以改变函数内部this指向问题
    fn.call(thisArg,arr1,arr2,...)：可以调用此函数，fn内部的this就指向了thisArg对象，后面都是参数，主要用来实现继承
    fn.apply(thisArg,[argsArray])：可以调用此函数，fn内部的this指向了thisArg对象，参数使用数组传递，主要可以利用数学内置对象求数组的一些最大值最小值问题
    fn.bind(thisArg,arr1,arr2,...)：不会调用函数，在fn运行时，内部this指向了thisArg对象，后面都是参数，返回了由指定的this值和初始化参数改造的原函数拷贝，在实际的开发中经常会用到bind方法，不会立即调用函数，且想要改变this指向，例如定时器的使用

# 严格模式下的变化：
    1.变量名必须先声明再使用
    2.不能随意删除已经声明好的变量
    3.严格模式下全局作用域中函数中的this是undefined
    4.严格模式下，如果构造函数不加new调用，this会报错
    5.定时器this还是指向window


# 闭包与递归
    1.闭包：指有权方访问另一个函数作用域中变量的函数，此时被访问的变量的函数为闭包函数
    2.闭包作用：延伸了变量的作用范围
    3.递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数，即函数内部自己调用自己，要有返回值
    4.递归函数最大问题：即容易死循环，出现栈溢出现象，所以一定要加判断退出条件return

# 深拷贝与浅拷贝
    1.浅拷贝：只是拷贝一层，更深层次对象级别的只拷贝引用地址
    2.深拷贝：拷贝多层，每一级别的数据都会拷贝
    ES6新增浅拷贝方法：Object.assign(target, source);

# 正则表达式 Regular Expression
    1.正则表达式：用于匹配字符串中字符组合的模式，也是对象，具有输入框验证匹配功能、敏感词替换功能、字符串提取特定部分功能
    2.一般都是使用字面量的方式来创建正则表达式，通过test方法检测字符串是否符合正则表达式，rg.test(args),返回true或false
    3.边界符：^以什么开头  $以什么结尾
    4.字符类：[]表示有一系列字符可供选择，只要匹配方括号中的其中一个就可以了，/^[]$/ 必须是方括号中里面的某一个才是true
    5.量词符：*重复0次或多次，+重复1次或多次，?重复1次或0次，{n}重复n次，{n,}重复n次或多次，{n,m}重复大于等于n次且小于等于m次
    6.预定义类：\d等价于[0-9]，\D等价于[^0-9]，\w等价于[a-zA-Z0-9_]，\W[^a-zA-Z0-9_]，\s等价于[\t\r\n\v\f]，\S等价于[^\t\r\n\v\f]
    7.正则修饰符：/内容/g 全局匹配，/内容/i 忽略大小写，/内容/gi 全局匹配且忽略大小写
    7.替换 str.replace('正则或字符串'，替换的str)

# let、const、var声明变量的区别
    1.var其作用域为该语句所在的函数内，且存在变量提升现象
    2.let其作用域为该语句所在的代码块内，不存在变量提升
    3.const声明常量，定义后，不能修改常量的值

# 解构赋值
    1.数组解构，按照一一对应的关系，来进行提取赋值给变量，没有对应的值，则为undefined
    2.对象解构，按照对象的属性，来进行提取赋值给相对应的变量

# 箭头函数
    1.用来简化函数定义语法的
    2.() => {}，一般()里面放的是函数形参，{}里则是函数体
    3.const fn = ()=>{}, 箭头函数调用，则直接fn()
    4.函数体中若只有一句代码，且代码的执行结果就是返回值，则可以省略{}
    5.如果形参只有一个，则可以省略()
    6.箭头函数不绑定this，箭头函数中没有自己的this关键字，如果在箭头函数中使用this，则这个this关键字将指向箭头函数定义位置中的this

# 剩余参数、扩展运算符
    1.即(...args)代表了所有的参数，是一个数组，也可以和解构赋值搭配使用
    2.扩展运算符可以将数组或者对象转为用逗号分割的参数序列，即...ary
    3.扩展运算符可应用于合并数组，也可以将伪数组转换为真正的数组

# Array的扩展方法，可以查询资料
    1.Array.from(ary)：将伪数组ary转换为真正的数组，后面也可以接收其他参数
    2.Array.find()：用于找出第一个符合条件的数组成员，参数可以是函数
    3.Array.findIndex()：用于找出第一个符合条件的数组成员的索引值，参数可以是函数
    4.Array.includes()：用于表示某个数组是否包含给定的值，返回布尔值

# 模板字符串
    1.反引号里面即模板字符串，可以解析变量${},可以换行,可以调用函数显示返回值,
    2.startWith()、endsWith()，判断字符串是否以某字符串开头，以某字符串结尾，返回布尔值
    3.str.repeat(n)，将原字符串重复n次，返回一个新字符串
    4.Set类似于数组，但成员的值都是唯一的，不允许重复，可以进行数组去重


